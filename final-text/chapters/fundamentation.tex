
\chapter{Fundamentação} \label{ch:fundamentation}

Este Capítulo apresenta a fundamentação necessária para o entendimento do trabalho. 
Ele é separado em duas Seções, na primeira, são apresentados os conceitos básicos 
sobre o StarVZ e seu \emph{workflow} e, na segunda, discute-se sobre os trabalhos 
relacionados.

\section{Conceitos Básicos} \label{sect:basic-concepts}

O StarVZ \cite{ref:starvz} é um \emph{workflow} de análise de performance cujo 
objetivo é auxiliar na avaliação e na verificação de hipóteses sobre a execução de 
aplicações \emph{task-based} em ambientes heterogêneos que são executados sobre o
\emph{runtime} StarPU \cite{ref:starpu}. Ele é composto de duas fases, cada uma 
delas sendo uma combinação de diversas ferramentas, que resultam em um \emph{framework}
rápido, consistente, flexível e versátil.

Na primeira fase, que pode ser visualizada na Figura \ref{fig:starvz-workflow1}, as 
saídas do StarPU, que são arquivos em um formato binário, são transformadas e exportadas
através da ferramenta \texttt{starpu\_fxt\_tool} para dois arquivos: DAG no formato DOT 
e Trace no formato PAJE. Essa etapa gera eventos com informação de data e hora, que 
descrevem o comportamento da aplicação para todos os recursos envolvidos. Além disso, 
também são gerados dados sobre o \emph{runtime} do StarPU, como número de tarefas submetidas,
número de tarefas prontas, arquitetura da plataforma, etc.

\begin{figure}[h]
 \centerline{\includegraphics[width=1\textwidth]{./img/step1-final.pdf}}
 \caption{\emph{Workflow} de pré-processamento do StarVZ.}
 \label{fig:starvz-workflow1}
\end{figure}

Em seguida, é realizada uma verificação de integridade estrutural e temporal dos
arquivos trace. Ela é executada via \texttt{pj\_dump}, gerando cinco arquivos: o arquivo states 
possui informações sobre as tarefas executadas e seu comportamento no \emph{runtime}; variables
consiste em métricas de performance da plataforma e runtime; events possui informações sobre a 
utilização de recursos; links contém dados sobre comunicação MPI; e as informações de plataforma 
são registradas no arquivo entities. O DAG também passa por uma conversão e por fim, todos os 
arquivos são gravados no formato \emph{Comma-Separated Value} (CSV).

Finalmente, os dados escritos em CSV são lidos, filtrados, agregados e combinados em 
uma ferramenta implementada sobre R, utilizando-se bibliotecas oriundas do pacote 
\texttt{tidyverse} para a manipulação de dados. As saídas são escritas no formato \emph{FEATHER}
\cite{ref:feather}.

A segunda fase do \emph{workflow} inicia pela leitura das saídas da fase anterior. Cada arquivo
torna-se um \emph{data frame}, e os dados da execução inteira são unificados em uma estrutura.
É possível ter múltiplos \emph{traces} de aplicações sendo analisados em paralelo
para comparação, basta multiplicar a leitura com entradas diferentes e 
elas podem posteriormente ser combinadas em uma única visualização. A criação dos gráficos ainda 
possui processamento de dados, o que traz certa flexibilidade para as visualizações. O usuário 
parametriza o sistema com um arquivo configuração, no formato YAML, como última etapa dessa fase
para que a montagem da visualização seja customizada. Finalmente, o usuário pode analisar os 
gráficos gerados pela ferramenta.

Nos experimentos realizados em \citet{ref:starvz}, em uma máquina equipada com um Intel(R) Xeon(R) 
CPU E3-1225 v3 @3.20GHz e 32GB de memória principal e com uma entrada de aproximadamente 18GB, a 
primeira fase do \emph{workflow} levou cerca de 32 minutos para executar: a execução da \texttt{starpu\_fxt\_tool}
levou em torno de 10 minutos, o \texttt{pj\_dump} levou cerca de 9 minutos e a ferramenta R levou cerca de 13
minutos. Já a segunda fase do \emph{workflow}, para executar a leitura dos arquivos FEATHER e gerar
a visualização levou em torno de 2 minutos.

\section{Trabalhos Relacionados}\label{sect:related-work}

O trabalho de \citet{ref:drakestarvz} foi o primeiro a tentar otimizar o fluxo do StarVZ. 
Sua principal motivação foi a melhoria de performance da etapa de manipulação de dados, a mais
custosa de acordo com os experimentos observados, com o objetivo de permitir o processamento de 
entradas maiores em um tempo razoável.

Nele utilizou-se Drake, uma biblioteca para a linguagem de programação R, cujo foco é executar apenas as 
partes necessárias de um \emph{workflow} de análise de dados, evitando os passos desnecessários que não mudarão
suas saídas. Isso é realizado modelando as computações como um \emph{directed acyclic graph} (DAG) de tarefas e 
armazenando em cache os resultados daquelas já executadas. Além disso, Drake também possui suporte a paralelismo
para a execução de tarefas independentes.

Para modelar o StarVZ dessa forma, foram necessárias mudanças cujo objetivo era explicitar 
dependências e postergar junções de \emph{data frames}. Depois da identificação dos fluxos independentes 
no \emph{workflow}, foi utilizado Drake para criar um plano de execução, que consiste em uma declaração
das tarefas, onde cada uma é representada por uma função R. Na criação do plano, a biblioteca analisa cada
uma das tarefas, suas entradas e saídas, para determinar dependências e gerar o DAG.

Com esta modelagem, não foram observadas melhorias de performance no StarVZ. De acordo com \citet{ref:drakestarvz},
o sistema que realiza cache de resultados intermediários da biblioteca acaba tendo que armazenar muitos dados em disco devido
ao tamanho dos \emph{data frames} gerados pelas entradas, prejudicando o tempo total de processamento.
Em relação ao suporte a paralelismo da biblioteca, ele é limitado pela falta de suporte nativo a multi-thread da linguagem R.
Por isso, Drake oferece essa funcionalidade instânciando múltiplas sessões R, que são processos separados. A comunicação
entre esses processos é realizada pelo mesmo sistema de cache citado anteriormente, consequentemente, resultando nos mesmos
problemas.

Há outras alternativas para melhoria de performance dessa etapa do \emph{workflow}. Existem pacotes, como o Rmpi \cite{ref:rmpi}
e o pbdR \cite{ref:pbdr}, que permitem a utilização de MPI com R. Com essas bibliotecas, é possível realizar adaptações no 
StarVZ para utilização de \emph{Explicit parallelism}. É importante salientar que, embora essas bibliotecas facilitem a 
utilização de recursos paralelos e distribuídos, para utilizar essa abordagem é necessário dominar conceitos de programação
paralela e distribuída para conseguir gerar código eficiente. A vantagem é que, como o desenvolvedor tem controle absoluto sobre
a execução paralela, o resultado pode ter uma performance superior a abordagens de que adotam \emph{Implicit parallelism}, como o Drake.